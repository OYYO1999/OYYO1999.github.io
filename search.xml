<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OpenFOAM中的场松弛和方程松弛</title>
    <url>/archives/ec2bd2a0.html</url>
    <content><![CDATA[<h1 id="场松弛和方程松弛">场松弛和方程松弛</h1>
<p>之前在调整PIMPLE算法中，里面对松弛因子的调整有： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">relaxationFactors</span><br><span class="line">&#123;</span><br><span class="line">	fields</span><br><span class="line">	&#123;</span><br><span class="line">		p	<span class="number">0.9</span>;</span><br><span class="line">		pFinal	<span class="number">0.9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	equations</span><br><span class="line">	&#123;</span><br><span class="line">		p		<span class="number">0.9</span>;</span><br><span class="line">		U               <span class="number">0.9</span>;</span><br><span class="line">		UFinal		 <span class="number">0.9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  查询资料发现：在进行松弛的过程中，实际上是有两种类型的松弛化的。一种是对动量方程的松弛，目的是增加对角占优的特性，使得方程更加稳定，不容易发散。另一种是直接对场如压力场、湍动能场和温度场进行松弛。</p>
<h2 id="方程的松弛化">方程的松弛化</h2>
<p>  动量方程可以写成以下的形式：</p>
<p><span class="math display">\[
a_P\bold{U_P}+\sum_N a_N \bold{U_N} = R_P
\]</span></p>
<p>  其中<span class="math inline">\(a_P\)</span>是对角元，<span class="math inline">\(a_N\)</span>是其他非对角元。那么在两端在两端加上一个松弛因子，即有：
<span class="math display">\[
\frac{1-\alpha}{\alpha}a_P\bold{U_P}+a_P\bold{U_P}+\sum_N a_N \bold{U_N}
= R_P + \frac{1-\alpha}{\alpha}a_P\bold{U_P}
\]</span></p>
<p>  那么当收敛的时候<span class="math inline">\(\bold{U_P^{old}}=\bold{U_P}\)</span>，两端附加项就消失了。
  整理公式有，可以得到： <span class="math display">\[
\frac{1}{\alpha}a_P\bold{U_P}+\sum_N a_N \bold{U_N} = R_P +
\frac{1-\alpha}{\alpha} a_P \bold{U_P^{old}}
\]</span></p>
<p>  那么当<span class="math inline">\(\alpha \rightarrow
0\)</span>，对角元将会变得更大，方程也就变得更加稳定(不容易发散)。</p>
<h2 id="场的离散">场的离散</h2>
<p>  传统方式里面，我们使用松弛化，是应用在解向量/矩阵里面。
  比如对于压力场的解，可以松弛化为： <span class="math display">\[
p=\alpha p_{new} + (1-\alpha)p_{old}
\]</span>
  同理，我们也可以将其应用在其他的标量输运方程里面，比如说湍动能<span class="math inline">\(k\)</span>和温度项<span class="math inline">\(T\)</span>: <span class="math display">\[
k=\alpha k_{new} + (1-\alpha)k_{old}
T=\alpha T_{new} + (1-\alpha)T_{old}
\]</span></p>
<p>  <span class="math inline">\(\alpha\)</span>是松弛因子，如果<span class="math inline">\(\alpha=1\)</span>，那么当前迭代步的值将就是当前迭代步的值，没有任何旧迭代步的影响。如果<span class="math inline">\(\alpha=0\)</span>，当前迭代步等于前一个迭代步的值。</p>
<h1 id="参考连接">参考连接：</h1>
<p>[1] <a href="%5BCFD%5D%20The%20PISO%20Algorithm">[CFD] The PISO
Algorithm</a> [2] <a href="https://www.cfd-online.com/Forums/openfoam-solving/196204-difference-between-fields-equations-relaxation-sub-directories-fvsolution.html">Difference
between "fields" and "equations" relaxation sub-directories in
fvSolution</a> [3] <a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-solvers-under-relaxation.html">OpenFOAM
User Guide:Under relaxation</a></p>
]]></content>
      <categories>
        <category>About OpenFOAM</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/archives/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<h3 id="quick-operation">Quick Operation：</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>About Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFOAM槽道流动怎么添加初始湍流脉动</title>
    <url>/archives/3064a881.html</url>
    <content><![CDATA[<h1 id="openfoam槽道流动怎么添加初始湍流脉动">OpenFOAM槽道流动怎么添加初始湍流脉动</h1>
<p>  
在槽道流动计算中，湍流状态是很难发生的，因为计算中扰动比较难发生，一般都是人工进行添加来进行计算，但是由于人工添加脉动可能在计算过程逐渐被耗散，因此需要一些专门方式来进行添加脉动。</p>
<h2 id="boxturb">boxTurb</h2>
<p>  <strong>boxturb前处理工具</strong><a href="https://www.cfd-china.com/topic/5214/%E9%9D%9E%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BCboxturb%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9F%E5%BA%A6%E5%9C%BA%E9%97%AE%E9%A2%98"><sup>1</sup></a>：不支持非均匀化网格，需要网格进行均匀化处理，最后mapFields到其他网格上去，进行继续计算。
  具体也可以参考A boxTurb16 and dnsFoam tutorial<a href="https://www.jianguoyun.com/p/Devd2FgQvPa5CxiB8pcFIAA"><sup>2</sup></a>简单的介绍。
  具体例子见此贴子<a href="https://www.jianguoyun.com/p/Devd2FgQvPa5CxiB8pcFIAA"><sup>3</sup></a>。
## Codestream</p>
<p>  EugeneDeVilliers博士论文提到的方法<a href="https://www.researchgate.net/publication/230606613_The_Potential_of_Large_Eddy_Simulation_for_the_Modeling_of_Wall_Bounded_Flows_Eugene_de_Villiers"><sup>4</sup></a>，见章节5.1.2。
  <strong>代码解析：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">internalField   #codeStream</span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">    #&#123;</span><br><span class="line">        <span class="type">const</span> IOdictionary&amp; d = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> IOdictionary&amp;&gt;(dict);</span><br><span class="line">        <span class="type">const</span> objectRegistry&amp; db = d.<span class="built_in">db</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> fvMesh&amp; mesh = <span class="built_in">refCast</span>&lt;<span class="type">const</span> fvMesh&gt;(d.<span class="built_in">db</span>());</span><br><span class="line"></span><br><span class="line">        volVectorField&amp; fld =</span><br><span class="line">        <span class="built_in">const_cast</span>&lt;volVectorField&amp;&gt;(db.<span class="built_in">lookupObject</span>&lt;volVectorField&gt;(<span class="string">&quot;U&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// settings need modified start</span></span><br><span class="line">        <span class="comment">// direction</span></span><br><span class="line">        direction streamDir = <span class="number">0</span>;</span><br><span class="line">        direction spanDir = <span class="number">2</span>;</span><br><span class="line">        direction heightDir = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// half height</span></span><br><span class="line">        <span class="type">const</span> scalar h = <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">const</span> scalar Um = <span class="number">0.4</span>;</span><br><span class="line">        <span class="type">const</span> scalar Retau = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">const</span> scalar nu = <span class="number">2e-5</span>;</span><br><span class="line">        <span class="type">const</span> scalar utau = Retau*nu/h;</span><br><span class="line">        <span class="comment">// settings need modified end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// spanwise wavenumber: spacing z+ = 200</span></span><br><span class="line">        <span class="type">const</span> scalar betaPlus = <span class="number">2.0</span>*constant::mathematical::pi*(<span class="number">1.0</span>/<span class="number">200.0</span>);</span><br><span class="line">        <span class="comment">// streamwise wave number: spacing x+ = 500</span></span><br><span class="line">        <span class="type">const</span> scalar alphaPlus = <span class="number">2.0</span>*constant::mathematical::pi*(<span class="number">1.0</span>/<span class="number">500.0</span>);</span><br><span class="line">        <span class="type">const</span> scalar sigma = <span class="number">0.00055</span>;</span><br><span class="line">        <span class="type">const</span> scalar epsilon = Um/<span class="number">200.0</span>;</span><br><span class="line">        <span class="type">const</span> scalar duplus = Um*<span class="number">0.25</span>/utau; <span class="comment">//具体见Eugene De Villiers的博士论文</span></span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> setBulk = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> perturb = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Random number generator</span></span><br><span class="line">        <span class="function">Random <span class="title">perturbation</span><span class="params">(<span class="number">1234567</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> vectorField&amp; centres = mesh.<span class="built_in">C</span>();</span><br><span class="line"></span><br><span class="line">        forAll(centres, celli)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// add a small (+/-20%) random component to enhance symetry breaking</span></span><br><span class="line">            scalar deviation=<span class="number">1.0</span> + <span class="number">0.2</span>*perturbation.<span class="built_in">GaussNormal</span>&lt;scalar&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> vector&amp; cCentre = centres[celli];</span><br><span class="line"></span><br><span class="line">            scalar zplus = cCentre[spanDir]*Retau/h;</span><br><span class="line">            scalar y = <span class="built_in">min</span>(cCentre[heightDir], <span class="number">2</span>*h-cCentre[heightDir]);</span><br><span class="line">            scalar yplus = y*Retau/h;</span><br><span class="line">            scalar xplus = cCentre[streamDir]*Retau/h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (setBulk)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// laminar parabolic profile</span></span><br><span class="line">                fld[celli] = vector::zero;</span><br><span class="line"></span><br><span class="line">                fld[celli][streamDir] =</span><br><span class="line">                    <span class="number">3.0</span>*Um * (y/h - <span class="number">0.5</span>*<span class="built_in">sqr</span>(y/h));</span><br><span class="line">                    <span class="comment">// Blasius Um*( 5/4*(1-pow(zloc-1,4)));</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (perturb)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// streak streamwise velocity</span></span><br><span class="line">                fld[celli][streamDir] +=</span><br><span class="line">                    (utau * duplus/<span class="number">2.0</span>) * (yplus/<span class="number">40.0</span>)</span><br><span class="line">                    * Foam::<span class="built_in">exp</span>(-sigma * Foam::<span class="built_in">sqr</span>(yplus) + <span class="number">0.5</span>)</span><br><span class="line">                    * Foam::<span class="built_in">cos</span>(betaPlus*zplus)*deviation;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// streak spanwise perturbation</span></span><br><span class="line">                fld[celli][spanDir] =</span><br><span class="line">                    epsilon</span><br><span class="line">                * Foam::<span class="built_in">sin</span>(alphaPlus*xplus)</span><br><span class="line">                * yplus</span><br><span class="line">                * Foam::<span class="built_in">exp</span>(-sigma*Foam::<span class="built_in">sqr</span>(yplus))</span><br><span class="line">                * deviation;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fld.<span class="built_in">writeEntry</span>(<span class="string">&quot;&quot;</span>, os);</span><br><span class="line">        <span class="comment">// os &lt;&lt; fld.internalField();</span></span><br><span class="line"></span><br><span class="line">    #&#125;;</span><br><span class="line"></span><br><span class="line">    codeInclude</span><br><span class="line">    #&#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fvCFD.H&quot;</span></span></span><br><span class="line">    #&#125;;</span><br><span class="line"> </span><br><span class="line">    codeOptions</span><br><span class="line">    #&#123;</span><br><span class="line">        -I$(LIB_SRC)/finiteVolume/lnInclude \</span><br><span class="line">        -I$(LIB_SRC)/meshTools/lnInclude</span><br><span class="line">    #&#125;;</span><br><span class="line"></span><br><span class="line">    codeLibs</span><br><span class="line">    #&#123;</span><br><span class="line">        -lfiniteVolume \</span><br><span class="line">        -lmeshTools</span><br><span class="line">    #&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  按照代码说明把需要改的参数改好，将上述代码写入算例/0/U文件中，即可计算，具体效果如下图。
<img data-src="channelflow.gif" alt="Channel Flow">
<center style="color:#C0C0C0;text-decoration:underline">
利用CodeStream生成的湍流
</center>
<h2 id="mapfields">mapFields</h2>
<p>  The mapFields function object maps input fields from local mesh to
secondary mesh at runtime. mapFields
可以使得之前的湍流流场(速度场和压力场)插值到新算例中，从来进行计算，这样计算大大增加了计算速度，可以很快地出现湍流现象。
  格式如下：   Usage:
<code>mapFields [OPTIONS] &lt;sourceCase&gt;</code><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-fos-field-mapFields.html"><sup>7</sup></a>
  Options的选项:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">-<span class="keyword">case</span> &lt;dir&gt;       <span class="function">Specify <span class="keyword">case</span> directory to <span class="title">use</span> <span class="params">(instead of cwd)</span></span></span><br><span class="line"><span class="function">-consistent       Source <span class="keyword">and</span> target geometry <span class="keyword">and</span> boundary conditions identical</span></span><br><span class="line"><span class="function">-mapMethod &lt;word&gt;</span></span><br><span class="line"><span class="function">                Specify the mapping method</span></span><br><span class="line"><span class="function">-parallelSource   The source is decomposed</span></span><br><span class="line"><span class="function">-parallelTarget   The target is decomposed</span></span><br><span class="line"><span class="function">-sourceDecomposeParDict &lt;file&gt;  Read decomposePar dictionary from specified location</span></span><br><span class="line"><span class="function">-sourceRegion &lt;word&gt;</span></span><br><span class="line"><span class="function">                Specify the source region</span></span><br><span class="line"><span class="function">-sourceTime &lt;scalar|&#x27;latestTime&#x27;&gt;</span></span><br><span class="line"><span class="function">                Specify the source time</span></span><br><span class="line"><span class="function">-subtract         Subtract mapped source from target</span></span><br><span class="line"><span class="function">-targetDecomposeParDict &lt;file&gt;</span></span><br><span class="line"><span class="function">                Read decomposePar dictionary from specified location</span></span><br><span class="line"><span class="function">-targetRegion &lt;word&gt;</span></span><br><span class="line"><span class="function">                Specify the target region</span></span><br><span class="line"><span class="function">-doc              Display documentation in browser</span></span><br><span class="line"><span class="function">-help             Display <span class="type">short</span> help <span class="keyword">and</span> exit</span></span><br><span class="line"><span class="function">-help-full        Display full help <span class="keyword">and</span> exit</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Map volume fields from one mesh to another</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Using: OpenFOAM-v2206 (<span class="number">2206</span>) - visit www.openfoam.com</span></span><br></pre></td></tr></table></figure>
<p>  其中需要注意的是：consistent代表的是几何条件和边界条件都相同的时候使用，当不相同的时候(比如在使用光滑算例插值到有结构的算例中去的时候，就不能使用consistent
Options)<a href="https://www.cfd-online.com/Forums/openfoam-pre-processing/81780-issues-mapfields.html"><sup>8</sup></a>。</p>
<h1 id="参考链接">参考链接</h1>
<ul>
<li>[1] <a href="https://www.cfd-china.com/topic/5214/%E9%9D%9E%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BCboxturb%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9F%E5%BA%A6%E5%9C%BA%E9%97%AE%E9%A2%98">非均匀网格boxTurb初始化速度场问题</a>;</li>
<li>[2] <a href="https://www.jianguoyun.com/p/Devd2FgQvPa5CxiB8pcFIAA">A
boxTurb16 and dnsFoam tutorial</a></li>
<li>[3] <a href="https://www.cfd-online.com/Forums/openfoam-pre-processing/133364-preprocessing-turbulent-pipe-flow.html">No
Turbulence Preprocessing of Turbulent Pipe Flow</a></li>
<li>[4] <a href="https://www.researchgate.net/publication/230606613_The_Potential_of_Large_Eddy_Simulation_for_the_Modeling_of_Wall_Bounded_Flows_Eugene_de_Villiers">De
Villiers E. The potential of large eddy simulation for the modeling of
wall bounded flows[J]. Imperial College of Science, Technology and
Medicine, 2006.</a></li>
<li>[5] <a href="https://www.cfd-online.com/Forums/openfoam-pre-processing/134217-boxturb-utility.html">boxTurb
utility</a></li>
<li>[6] <a href="https://www.openfoam.com/documentation/guides/latest/api/boxTurb_8C.html">boxTurb.C
File Reference</a></li>
<li>[7] <a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-fos-field-mapFields.html">User
Guide: mapFields - OpenFOAM</a></li>
<li>[8] <a href="https://www.cfd-online.com/Forums/openfoam-pre-processing/81780-issues-mapfields.html">Issues
with mapFields</a></li>
</ul>
]]></content>
      <categories>
        <category>About OpenFOAM</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>Channel Flow</tag>
      </tags>
  </entry>
</search>
